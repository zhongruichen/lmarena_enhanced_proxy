ä½ è¯´å¾—å¯¹ï¼Œè¿™ä¸ªç¨‹åºå­˜åœ¨ä¸¥é‡çš„é€»è¾‘é”™è¯¯ã€‚æµ‹è¯•100æ¬¡å…¨éƒ¨å¤±è´¥å´è¢«å½’ä¸º"å®Œç¾"æ˜¯å®Œå…¨é”™è¯¯çš„ã€‚è®©æˆ‘æ·±åº¦åˆ†æå¹¶ä¿®å¤è¿™äº›é—®é¢˜ï¼š

**æ ¸å¿ƒé—®é¢˜ï¼š**
1. åˆ†ç±»é€»è¾‘é”™è¯¯ - åªçœ‹æ˜¯å¦å®Œæˆ100æ¬¡ï¼Œä¸çœ‹æˆåŠŸç‡
2. æ—¥å¿—å¤ªç®€ç•¥ - çœ‹ä¸åˆ°æ¯æ¬¡è¯·æ±‚çš„å…·ä½“ç»“æœ
3. é”™è¯¯å¤„ç†ä¸å½“ - å¯èƒ½æ‰€æœ‰è¯·æ±‚éƒ½å¤±è´¥äº†ä½†æ²¡æœ‰æ­£ç¡®è®°å½•

**æ·±åº¦ä¿®å¤æ–¹æ¡ˆï¼š**

````html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æš´æ‰“geminiä¸€ç™¾æ¬¡ - å¢å¼ºç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .warning-banner {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
        }
        
        .input-section {
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }
        
        textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            resize: vertical;
            font-family: monospace;
        }
        
        .control-panel {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-input label {
            font-weight: bold;
            color: #555;
        }
        
        .control-input input {
            width: 80px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .control-input.checkbox {
            background: #e3f2fd;
            padding: 8px 12px;
            border-radius: 5px;
        }
        
        .control-input.checkbox input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        
        button {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-start {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-start:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-stop {
            background: #ff6b6b;
            color: white;
        }
        
        .btn-clear {
            background: #6c757d;
            color: white;
        }
        
        .btn-export {
            background: #28a745;
            color: white;
        }
        
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .progress-section {
            margin: 30px 0;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .results-section {
            margin-top: 30px;
        }
        
        .result-group {
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }
        
        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #dee2e6;
        }
        
        .group-title {
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .group-count {
            font-size: 0.9em;
            color: #6c757d;
            margin-left: 10px;
        }
        
        .perfect { color: #28a745; }
        .excellent { color: #17a2b8; }
        .qualified { color: #ffc107; }
        .unstable { color: #fd7e14; }
        .error { color: #dc3545; }
        .manual-stop { color: #6c757d; }
        .invalid { color: #dc3545; }
        
        .key-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .key-item.perfect { border-left-color: #28a745; }
        .key-item.excellent { border-left-color: #17a2b8; }
        .key-item.qualified { border-left-color: #ffc107; }
        .key-item.unstable { border-left-color: #fd7e14; }
        .key-item.error { border-left-color: #dc3545; }
        .key-item.manual-stop { border-left-color: #6c757d; }
        .key-item.invalid { border-left-color: #dc3545; }
        
        .key-text {
            font-family: monospace;
            font-size: 0.9em;
            flex: 1;
            margin-right: 10px;
            word-break: break-all;
        }
        
        .key-stats {
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 0.9em;
        }
        
        .copy-btn {
            padding: 5px 15px;
            font-size: 0.9em;
            background: #6c757d;
        }
        
        .copy-btn:hover {
            background: #5a6268;
        }
        
        .log-section {
            margin-top: 30px;
            background: #212529;
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #00ff00;
            padding-left: 10px;
        }
        
        .log-entry.error {
            color: #ff6b6b;
            border-left-color: #ff6b6b;
        }
        
        .log-entry.warning {
            color: #ffc107;
            border-left-color: #ffc107;
        }
        
        .log-entry.success {
            color: #00ff00;
            border-left-color: #00ff00;
        }
        
        .log-entry.info {
            color: #17a2b8;
            border-left-color: #17a2b8;
        }
        
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .batch-info {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #007bff;
        }
        
        .testing-indicator {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .testing-indicator.active {
            display: flex;
        }
        
        .subgroup {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }
        
        .subgroup h4 {
            color: #6c757d;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .current-testing {
            background: #d4edda;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #28a745;
        }
        
        .current-testing.active {
            display: block;
        }
        
        .test-details {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
        
        .test-detail-item {
            flex: 1;
        }
        
        .test-detail-label {
            font-size: 0.9em;
            color: #6c757d;
        }
        
        .test-detail-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }
        
        .time-estimate {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            color: #1976d2;
        }

        .batch-progress {
            background: #f0f8ff;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #4169e1;
        }
        
        .batch-launch-info {
            background: #f5f5dc;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            color: #8b4513;
        }
        
        .debug-panel {
            background: #f8f9fa;
            border: 2px dashed #6c757d;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .debug-panel h3 {
            color: #6c757d;
            margin-bottom: 10px;
        }
        
        .debug-info {
            font-family: monospace;
            font-size: 0.9em;
            color: #495057;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ æš´æ‰“geminiä¸€ç™¾æ¬¡ - å¢å¼ºç‰ˆ</h1>
        
        <div class="warning-banner">
            <strong>âš ï¸ æ³¨æ„ï¼š</strong>
            <ol style="margin-top: 10px; padding-left: 20px;">
                <li>å¦‚é‡CORSé”™è¯¯ï¼Œè¯·ä½¿ç”¨æµè§ˆå™¨æ’ä»¶ç¦ç”¨CORSæ£€æŸ¥ï¼Œæˆ–ä½¿ç”¨ä»£ç†æœåŠ¡å™¨</li>
                <li>æµ‹è¯•å°†äº§ç”Ÿå¤§é‡è¯·æ±‚ï¼Œè¯·ç¡®ä¿ä½ æœ‰æƒé™æµ‹è¯•è¿™äº›APIå¯†é’¥</li>
                <li>æ¯ä¸ªå¯†é’¥æµ‹è¯•100æ¬¡ï¼Œæ¯æ¬¡é—´éš”20ç§’ï¼Œå•ä¸ªå¯†é’¥æœ€å¤šéœ€è¦çº¦33åˆ†é’Ÿ</li>
                <li>é»˜è®¤å¹¶å‘æ•°230ï¼Œæ¯éš”1ç§’å¯åŠ¨ä¸€ä¸ªå¯†é’¥ï¼Œå¯åŠ¨å®Œéœ€è¦çº¦4åˆ†é’Ÿ</li>
                <li>é‡åˆ°429é”™è¯¯ç«‹å³åœæ­¢è¯¥å¯†é’¥æµ‹è¯•ï¼ŒAPIå¯†é’¥åº”ä»¥ AIzaSy å¼€å¤´</li>
                <li><strong style="color: red;">åªæœ‰æˆåŠŸç‡è¾¾åˆ°95%ä»¥ä¸Šä¸”å‡ºç°429é”™è¯¯åœ¨95æ¬¡ä»¥åçš„å¯†é’¥æ‰ç®—å®Œç¾ï¼</strong></li>
            </ol>
        </div>
        
        <div class="input-section">
            <h3>è¾“å…¥APIå¯†é’¥ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰</h3>
            <textarea id="apiKeys" placeholder="è¯·è¾“å…¥Gemini APIå¯†é’¥ï¼Œæ¯è¡Œä¸€ä¸ª...
ä¾‹å¦‚ï¼š
AIzaSy...
AIzaSy..."></textarea>
            
            <div class="control-panel">
                <button class="btn-start" id="startBtn" onclick="startTesting()">
                    å¼€å§‹æµ‹è¯•
                </button>
                <button class="btn-stop" id="stopBtn" onclick="stopTesting()" disabled>
                    åœæ­¢æµ‹è¯•
                </button>
                <button class="btn-clear" onclick="clearResults()">
                    æ¸…ç©ºç»“æœ
                </button>
                <button class="btn-export" onclick="exportResults()">
                    å¯¼å‡ºæŠ¥å‘Š
                </button>
                <div class="control-input">
                    <label>æ‰¹æ¬¡å¤§å°ï¼š</label>
                    <input type="number" id="batchSize" value="230" min="1" max="500">
                </div>
                <div class="control-input">
                    <label>è¯·æ±‚é—´éš”(ç§’)ï¼š</label>
                    <input type="number" id="interval" value="20" min="1" max="60">
                </div>
                <div class="control-input">
                    <label>å¯åŠ¨å»¶æ—¶(æ¯«ç§’)ï¼š</label>
                    <input type="number" id="launchDelay" value="1000" min="100" max="5000">
                </div>
                <div class="control-input">
                    <label>é‡è¯•æ¬¡æ•°ï¼š</label>
                    <input type="number" id="maxRetries" value="3" min="1" max="10">
                </div>
                <div class="control-input checkbox">
                    <input type="checkbox" id="verboseLog" checked>
                    <label for="verboseLog">è¯¦ç»†æ—¥å¿—</label>
                </div>
            </div>
        </div>
        
        <div class="time-estimate" id="timeEstimate" style="display:none;">
            â±ï¸ é¢„è®¡æµ‹è¯•æ—¶é—´ï¼š<span id="estimatedTime"></span>
        </div>
        
        <div class="batch-launch-info" id="batchLaunchInfo" style="display:none;">
            ğŸš€ æ‰¹æ¬¡å¯åŠ¨è¿›åº¦ï¼š<span id="launchProgress"></span>
        </div>
        
        <div class="batch-progress" id="batchProgress" style="display:none;">
            ğŸ“Š å½“å‰æ‰¹æ¬¡è¿›åº¦ï¼š<span id="batchProgressText"></span>
        </div>
        
        <div class="current-testing" id="currentTesting" style="display:none;">
            <strong>å½“å‰æµ‹è¯•è¯¦æƒ…</strong>
            <div class="test-details">
                <div class="test-detail-item">
                    <div class="test-detail-label">æ­£åœ¨æµ‹è¯•</div>
                    <div class="test-detail-value" id="currentKeyShort">-</div>
                </div>
                <div class="test-detail-item">
                    <div class="test-detail-label">è¿›åº¦</div>
                    <div class="test-detail-value" id="currentKeyProgress">0/100</div>
                </div>
                <div class="test-detail-item">
                    <div class="test-detail-label">æˆåŠŸç‡</div>
                    <div class="test-detail-value" id="currentKeySuccessRate">0%</div>
                </div>
                <div class="test-detail-item">
                    <div class="test-detail-label">çŠ¶æ€</div>
                    <div class="test-detail-value" id="currentKeyStatus">æµ‹è¯•ä¸­...</div>
                </div>
            </div>
        </div>
        
        <div class="stats-section">
            <div class="stat-card">
                <div class="stat-value" id="totalKeys">0</div>
                <div class="stat-label">æ€»å¯†é’¥æ•°</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="testedKeys">0</div>
                <div class="stat-label">å·²æµ‹è¯•</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="currentBatch">0</div>
                <div class="stat-label">å½“å‰æ‰¹æ¬¡</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalRequests">0</div>
                <div class="stat-label">æ€»è¯·æ±‚æ•°</div>
            </div>
        </div>
        
        <div class="testing-indicator" id="testingIndicator">
            <div class="spinner"></div>
            <span>æ­£åœ¨æµ‹è¯•ä¸­...</span>
            <span id="currentProgress"></span>
        </div>
        
        <div class="batch-info" id="batchInfo" style="display:none;">
            <strong>æ‰¹æ¬¡ä¿¡æ¯ï¼š</strong>
            <span id="batchDetails"></span>
        </div>
        
        <div class="progress-section">
            <h3>æ€»ä½“è¿›åº¦</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%">
                    0%
                </div>
            </div>
        </div>
        
        <div class="results-section">
            <h2>æµ‹è¯•ç»“æœ</h2>
            
            <div class="result-group">
                <div class="group-header">
                    <span class="group-title perfect">âœ¨ å®Œç¾ (æˆåŠŸç‡â‰¥95% ä¸” 429å‡ºç°åœ¨95æ¬¡å)<span class="group-count" id="perfectCount">(0)</span></span>
                    <button class="copy-btn" onclick="copyGroup('perfect')">å¤åˆ¶</button>
                </div>
                <div id="perfectKeys"></div>
            </div>
            
            <div class="result-group">
                <div class="group-header">
                    <span class="group-title excellent">ğŸŒŸ ä¼˜ç§€ (æˆåŠŸç‡â‰¥80% ä¸” 429å‡ºç°åœ¨70æ¬¡å)<span class="group-count" id="excellentCount">(0)</span></span>
                    <button class="copy-btn" onclick="copyGroup('excellent')">å¤åˆ¶</button>
                </div>
                <div id="excellentKeys"></div>
            </div>
            
            <div class="result-group">
                <div class="group-header">
                    <span class="group-title qualified">âœ… åˆæ ¼ (æˆåŠŸç‡â‰¥60% ä¸” 429å‡ºç°åœ¨50æ¬¡å)<span class="group-count" id="qualifiedCount">(0)</span></span>
                    <button class="copy-btn" onclick="copyGroup('qualified')">å¤åˆ¶</button>
                </div>
                <div id="qualifiedKeys"></div>
            </div>
            
            <div class="result-group">
                <div class="group-header">
                    <span class="group-title unstable">âš ï¸ ä¸ç¨³å®š (æˆåŠŸç‡<60% æˆ– 429è¿‡æ—©å‡ºç°)<span class="group-count" id="unstableCount">(0)</span></span>
                    <button class="copy-btn" onclick="copyGroup('unstable')">å¤åˆ¶</button>
                </div>
                <div id="unstableKeys">
                    <div class="subgroup">
                        <h4>å­ç»„1 (30-49æ¬¡æ—¶å‡ºç°429)</h4>
                        <div id="unstable1"></div>
                    </div>
                    <div class="subgroup">
                        <h4>å­ç»„2 (15-29æ¬¡æ—¶å‡ºç°429)</h4>
                        <div id="unstable2"></div>
                    </div>
                    <div class="subgroup">
                        <h4>å­ç»„3 (0-14æ¬¡æ—¶å‡ºç°429)</h4>
                        <div id="unstable3"></div>
                    </div>
                </div>
            </div>
            
            <div class="result-group">
                <div class="group-header">
                    <span class="group-title invalid">âŒ æ— æ•ˆå¯†é’¥ (è®¤è¯å¤±è´¥æˆ–è¯·æ±‚é”™è¯¯)<span class="group-count" id="invalidCount">(0)</span></span>
                    <button class="copy-btn" onclick="copyGroup('invalid')">å¤åˆ¶</button>
                </div>
                <div id="invalidKeys"></div>
            </div>
            
            <div class="result-group">
                <div class="group-header">
                    <span class="group-title manual-stop">ğŸ›‘ æ‰‹åŠ¨åœæ­¢<span class="group-count" id="manualStopCount">(0)</span></span>
                    <button class="copy-btn" onclick="copyGroup('manualStop')">å¤åˆ¶</button>
                </div>
                <div id="manualStopKeys"></div>
            </div>
            
            <div class="result-group">
                <div class="group-header">
                    <span class="group-title error">âš ï¸ å…¶ä»–é”™è¯¯<span class="group-count" id="errorCount">(0)</span></span>
                    <button class="copy-btn" onclick="copyGroup('error')">å¤åˆ¶</button>
                </div>
                <div id="errorKeys"></div>
            </div>
        </div>
        
        <div class="debug-panel" id="debugPanel" style="display:none;">
            <h3>ğŸ” è°ƒè¯•ä¿¡æ¯</h3>
            <div class="debug-info" id="debugInfo"></div>
        </div>
        
        <div class="log-section" id="logSection">
            <h3>æµ‹è¯•æ—¥å¿—</h3>
            <div id="logContent"></div>
        </div>
    </div>
    
    <script>
        // å…¨å±€çŠ¶æ€ç®¡ç†
        const state = {
            isRunning: false,
            testResults: new Map(),
            currentBatchNum: 0,
            totalKeysCount: 0,
            testedKeysCount: 0,
            totalRequestsCount: 0,
            currentAbortController: null,
            startTime: null,
            keyAbortControllers: new Map(),
            activePromises: new Set(),
            updateTimer: null,
            renderRequestId: null,
            retryDelays: [1000, 2000, 4000, 8000],
            finalUpdatePending: false,
            finalCategories: null,
            currentBatchStarted: 0,
            currentBatchCompleted: 0,
            currentTestingKey: null,
            verboseLogging: true
        };
        
        const TEST_COUNT = 100;
        const MAX_LOG_ENTRIES = 500;
        
        // æ£€æŸ¥ AbortController æ”¯æŒ
        const supportsAbortController = typeof AbortController !== 'undefined';
        
        function addLog(message, type = 'info') {
            const logContent = document.getElementById('logContent');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
            
            while (logContent.children.length > MAX_LOG_ENTRIES) {
                logContent.removeChild(logContent.firstChild);
            }
        }
        
        function updateCurrentTestingDisplay(keyData) {
            const testingDiv = document.getElementById('currentTesting');
            if (!keyData) {
                testingDiv.style.display = 'none';
                return;
            }
            
            testingDiv.style.display = 'block';
            const shortKey = keyData.key.substring(0, 20) + '...';
            const successRate = keyData.totalTests > 0 ? 
                (keyData.successCount / keyData.totalTests * 100).toFixed(1) : 0;
            
            document.getElementById('currentKeyShort').textContent = shortKey;
            document.getElementById('currentKeyProgress').textContent = `${keyData.totalTests}/${TEST_COUNT}`;
            document.getElementById('currentKeySuccessRate').textContent = `${successRate}%`;
            
            let status = 'æµ‹è¯•ä¸­...';
            if (keyData.failAt) {
                status = `ç¬¬${keyData.failAt}æ¬¡å‡ºç°429`;
            } else if (keyData.errorType) {
                status = `é”™è¯¯: ${keyData.errorType}`;
            } else if (keyData.totalTests === TEST_COUNT) {
                status = 'å®Œæˆ100æ¬¡';
            }
            document.getElementById('currentKeyStatus').textContent = status;
        }
        
        async function testSingleKey(apiKey, testNum, abortSignal) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{
                    parts: [{
                        text: "Hello, please respond with 'Hi'"
                    }]
                }],
                generationConfig: {
                    temperature: 0.1,
                    maxOutputTokens: 10
                }
            };
            
            state.totalRequestsCount++;
            updateStats();
            
            let controller = null;
            let timeoutId = null;
            const verboseLog = document.getElementById('verboseLog').checked;
            
            try {
                if (supportsAbortController) {
                    controller = new AbortController();
                    
                    if (abortSignal && abortSignal.aborted) {
                        return { success: false, error: 'aborted' };
                    }
                    
                    if (abortSignal) {
                        const abortHandler = () => {
                            if (controller && !controller.signal.aborted) {
                                controller.abort();
                            }
                        };
                        abortSignal.addEventListener('abort', abortHandler, { once: true });
                    }
                }
                
                timeoutId = setTimeout(() => {
                    if (controller && !controller.signal.aborted) {
                        controller.abort();
                    }
                }, 30000);
                
                const options = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                };
                
                if (controller) {
                    options.signal = controller.signal;
                }
                
                const response = await fetch(url, options);
                
                if (timeoutId) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                
                // å¤„ç†å“åº”
                if (response.status === 429) {
                    if (verboseLog) {
                        addLog(`[è¯·æ±‚ #${testNum}] æ”¶åˆ°429é”™è¯¯ - é€Ÿç‡é™åˆ¶`, 'warning');
                    }
                    return { success: false, error: '429', status: 429 };
                } else if (response.status === 401 || response.status === 403) {
                    if (verboseLog) {
                        addLog(`[è¯·æ±‚ #${testNum}] è®¤è¯å¤±è´¥ (${response.status})`, 'error');
                    }
                    return { success: false, error: 'invalid_key', status: response.status };
                } else if (response.status === 400) {
                    if (verboseLog) {
                        addLog(`[è¯·æ±‚ #${testNum}] è¯·æ±‚æ ¼å¼é”™è¯¯`, 'error');
                    }
                    return { success: false, error: 'bad_request', status: 400 };
                } else if (response.status >= 500) {
                    if (verboseLog) {
                        addLog(`[è¯·æ±‚ #${testNum}] æœåŠ¡å™¨é”™è¯¯ (${response.status})`, 'error');
                    }
                    return { success: false, error: 'server_error', status: response.status };
                } else if (response.ok) {
                    try {
                        const data = await response.json();
                        if (data && typeof data === 'object') {
                            if (verboseLog && testNum % 10 === 0) {
                                addLog(`[è¯·æ±‚ #${testNum}] æˆåŠŸ âœ“`, 'success');
                            }
                            return { success: true };
                        }
                        if (verboseLog) {
                            addLog(`[è¯·æ±‚ #${testNum}] å“åº”æ ¼å¼æ— æ•ˆ`, 'error');
                        }
                        return { success: false, error: 'invalid_response' };
                    } catch (e) {
                        if (verboseLog) {
                            addLog(`[è¯·æ±‚ #${testNum}] è§£æå“åº”å¤±è´¥`, 'error');
                        }
                        return { success: false, error: 'parse_error' };
                    }
                } else {
                    if (verboseLog) {
                        addLog(`[è¯·æ±‚ #${testNum}] æœªçŸ¥çŠ¶æ€ç : ${response.status}`, 'error');
                    }
                    return { success: false, error: `status_${response.status}`, status: response.status };
                }
                
            } catch (error) {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                
                const errorMessage = error?.message?.toLowerCase() || '';
                const errorName = error?.name?.toLowerCase() || '';
                
                if (errorName === 'aborterror' || errorMessage.includes('abort')) {
                    if (abortSignal && abortSignal.aborted) {
                        return { success: false, error: 'aborted' };
                    }
                    if (verboseLog) {
                        addLog(`[è¯·æ±‚ #${testNum}] è¶…æ—¶`, 'warning');
                    }
                    return { success: false, error: 'timeout' };
                }
                
                if (errorName === 'typeerror' || errorMessage.includes('failed to fetch')) {
                    if (verboseLog) {
                        addLog(`[è¯·æ±‚ #${testNum}] ç½‘ç»œé”™è¯¯æˆ–CORSé—®é¢˜`, 'error');
                    }
                    return { success: false, error: 'network' };
                }
                
                if (verboseLog) {
                    addLog(`[è¯·æ±‚ #${testNum}] æœªçŸ¥é”™è¯¯: ${errorMessage}`, 'error');
                }
                return { success: false, error: 'unknown', details: errorMessage };
            }
        }
        
        async function testKeyMultipleTimes(apiKey, keyIndex, batchSize) {
            const interval = parseInt(document.getElementById('interval').value) * 1000;
            const maxRetries = parseInt(document.getElementById('maxRetries').value);
            const verboseLog = document.getElementById('verboseLog').checked;
            
            let keyAbortController = null;
            if (supportsAbortController) {
                keyAbortController = new AbortController();
                state.keyAbortControllers.set(apiKey, keyAbortController);
            }
            
            const keyResult = {
                key: apiKey,
                successCount: 0,
                failAt: null,
                errorType: null,
                totalTests: 0,
                firstErrorAt: null,
                consecutiveErrors: 0,
                stoppedByUser: false,
                networkErrors: 0,
                timeoutErrors: 0,
                corsErrors: 0,
                serverErrors: 0,
                successRate: 0
            };
            
            state.currentTestingKey = keyResult;
            
            addLog(`[å¯†é’¥ ${keyIndex}/${batchSize}] å¼€å§‹æµ‹è¯•: ${apiKey.substring(0, 20)}...`, 'info');
            
            try {
                for (let i = 1; i <= TEST_COUNT; i++) {
                    if (!state.isRunning) {
                        keyResult.stoppedByUser = true;
                        break;
                    }
                    
                    keyResult.totalTests = i;
                    updateBatchProgress();
                    updateCurrentTestingDisplay(keyResult);
                    
                    let retryCount = 0;
                    let result = null;
                    
                    while (retryCount <= maxRetries) {
                        result = await testSingleKey(apiKey, i, keyAbortController?.signal);
                        
                        if (result.success) {
                            break;
                        }
                        
                        // ä¸éœ€è¦é‡è¯•çš„é”™è¯¯
                        if (result.error === '429' || 
                            result.error === 'invalid_key' || 
                            result.error === 'bad_request' ||
                            result.error === 'aborted') {
                            break;
                        }
                        
                        // å¯é‡è¯•çš„é”™è¯¯
                        if (result.error === 'timeout' || 
                            result.error === 'network' || 
                            result.error === 'server_error') {
                            
                            retryCount++;
                            
                            if (retryCount <= maxRetries) {
                                const retryDelay = state.retryDelays[Math.min(retryCount - 1, state.retryDelays.length - 1)];
                                if (verboseLog) {
                                    addLog(`[å¯†é’¥ ${keyIndex}] ç¬¬${i}æ¬¡è¯·æ±‚å¤±è´¥ï¼Œ${retryDelay/1000}ç§’åé‡è¯•...`, 'warning');
                                }
                                await new Promise(resolve => setTimeout(resolve, retryDelay));
                            }
                        } else {
                            break;
                        }
                    }
                    
                    // å¤„ç†ç»“æœ
                    if (result.success) {
                        keyResult.successCount++;
                        keyResult.consecutiveErrors = 0;
                    } else {
                        if (!keyResult.firstErrorAt) {
                            keyResult.firstErrorAt = i;
                        }
                        
                        // ç»Ÿè®¡é”™è¯¯
                        if (result.error === 'timeout') keyResult.timeoutErrors++;
                        if (result.error === 'network') keyResult.networkErrors++;
                        if (result.error === 'server_error') keyResult.serverErrors++;
                        
                        // å¤„ç†ç‰¹å®šé”™è¯¯
                        if (result.error === 'aborted') {
                            keyResult.stoppedByUser = true;
                            break;
                        } else if (result.error === '429') {
                            keyResult.failAt = i;
                            keyResult.errorType = '429';
                            addLog(`[å¯†é’¥ ${keyIndex}] åœ¨ç¬¬ ${i} æ¬¡å‡ºç°429é”™è¯¯ï¼Œåœæ­¢æµ‹è¯•`, 'warning');
                            break;
                        } else if (result.error === 'invalid_key') {
                            keyResult.errorType = 'invalid_key';
                            addLog(`[å¯†é’¥ ${keyIndex}] æ— æ•ˆå¯†é’¥`, 'error');
                            break;
                        } else if (result.error === 'bad_request') {
                            keyResult.errorType = 'bad_request';
                            addLog(`[å¯†é’¥ ${keyIndex}] è¯·æ±‚æ ¼å¼é”™è¯¯`, 'error');
                            break;
                        } else if (retryCount > maxRetries) {
                            keyResult.errorType = 'max_retries_exceeded';
                            addLog(`[å¯†é’¥ ${keyIndex}] è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°`, 'error');
                            break;
                        }
                    }
                    
                    // è®¡ç®—æˆåŠŸç‡
                    keyResult.successRate = keyResult.totalTests > 0 ? 
                        (keyResult.successCount / keyResult.totalTests * 100) : 0;
                    
                    // è¯·æ±‚é—´éš”
                    if (i < TEST_COUNT && state.isRunning && !keyResult.failAt && !keyResult.errorType) {
                        await new Promise(resolve => setTimeout(resolve, interval));
                    }
                }
            } catch (error) {
                console.error('æµ‹è¯•å¯†é’¥æ—¶å‘ç”Ÿæœªé¢„æœŸé”™è¯¯:', error);
                keyResult.errorType = 'unexpected_error';
                addLog(`[å¯†é’¥ ${keyIndex}] å‘ç”Ÿæœªé¢„æœŸé”™è¯¯: ${error.message}`, 'error');
            } finally {
                if (keyAbortController) {
                    state.keyAbortControllers.delete(apiKey);
                }
                state.currentBatchCompleted++;
                updateBatchProgress();
                updateCurrentTestingDisplay(null);
            }
            
            // æœ€ç»ˆæˆåŠŸç‡
            keyResult.successRate = keyResult.totalTests > 0 ? 
                (keyResult.successCount / keyResult.totalTests * 100) : 0;
            
            const statusText = keyResult.stoppedByUser ? '(æ‰‹åŠ¨åœæ­¢)' : 
                              keyResult.failAt ? `(ç¬¬${keyResult.failAt}æ¬¡å‡ºç°429)` :
                              keyResult.errorType ? `(${keyResult.errorType})` : 
                              keyResult.totalTests === 100 ? '(å®Œæˆ100æ¬¡)' : `(æµ‹è¯•${keyResult.totalTests}æ¬¡)`;
            
            addLog(`[å¯†é’¥ ${keyIndex}] æµ‹è¯•å®Œæˆ: ${keyResult.successCount}/${keyResult.totalTests} æˆåŠŸ (${keyResult.successRate.toFixed(1)}%) ${statusText}`, 
                   keyResult.successRate >= 60 ? 'success' : 'warning');
            
            return keyResult;
        }
        
        async function processBatch(keys, batchNum, totalBatches) {
            const launchDelay = parseInt(document.getElementById('launchDelay').value) || 1000;
            const results = [];
            
            state.currentBatchStarted = 0;
            state.currentBatchCompleted = 0;
            
            addLog(`===== å¼€å§‹ç¬¬ ${batchNum}/${totalBatches} æ‰¹ =====`);
            addLog(`æœ¬æ‰¹å…± ${keys.length} ä¸ªå¯†é’¥ï¼Œæ¯éš” ${launchDelay}ms å¯åŠ¨ä¸€ä¸ª`);
            
            document.getElementById('batchLaunchInfo').style.display = 'block';
            document.getElementById('batchProgress').style.display = 'block';
            
            const promises = [];
            for (let i = 0; i < keys.length; i++) {
                if (!state.isRunning) break;
                
                if (i > 0) {
                    await new Promise(resolve => setTimeout(resolve, launchDelay));
                }
                
                const key = keys[i];
                state.currentBatchStarted++;
                
                document.getElementById('launchProgress').textContent = 
                    `å·²å¯åŠ¨ ${state.currentBatchStarted}/${keys.length} ä¸ªå¯†é’¥`;
                
                if (state.currentBatchStarted % 10 === 0 || state.currentBatchStarted === keys.length) {
                    addLog(`å·²å¯åŠ¨ ${state.currentBatchStarted}/${keys.length} ä¸ªå¯†é’¥...`);
                }
                
                const promise = testKeyMultipleTimes(key, i + 1, keys.length)
                    .then(result => {
                        if (result) {
                            state.testResults.set(result.key, result);
                            state.testedKeysCount++;
                            results.push(result);
                            
                            updateStats();
                            updateProgress();
                            const allResults = Array.from(state.testResults.values());
                            const categories = categorizeResults(allResults);
                            state.finalCategories = categories;
                            displayResults(categories);
                        }
                        return result;
                    })
                    .catch(error => {
                        console.error('å¤„ç†å¯†é’¥æ—¶å‡ºé”™:', error);
                        addLog(`å¤„ç†å¯†é’¥æ—¶å‡ºé”™: ${error.message}`, 'error');
                        state.testedKeysCount++;
                        state.currentBatchCompleted++;
                        updateBatchProgress();
                        return null;
                    });
                
                promises.push(promise);
                state.activePromises.add(promise);
            }
            
            document.getElementById('batchLaunchInfo').style.display = 'none';
            addLog(`æœ¬æ‰¹ ${promises.length} ä¸ªå¯†é’¥å…¨éƒ¨å¯åŠ¨å®Œæˆï¼Œç­‰å¾…æµ‹è¯•å®Œæˆ...`);
            
            const startWaitTime = Date.now();
            await Promise.all(promises);
            const waitTime = Math.floor((Date.now() - startWaitTime) / 1000);
            
            promises.forEach(p => state.activePromises.delete(p));
            
            document.getElementById('batchProgress').style.display = 'none';
            addLog(`ç¬¬ ${batchNum} æ‰¹å¤„ç†å®Œæˆï¼Œè€—æ—¶ ${Math.floor(waitTime / 60)}åˆ†${waitTime % 60}ç§’`);
            addLog(`===== ç¬¬ ${batchNum}/${totalBatches} æ‰¹ç»“æŸ =====`);
            
            return results;
        }
        
        function updateBatchProgress() {
            if (state.currentBatchStarted > 0) {
                const progress = `${state.currentBatchCompleted}/${state.currentBatchStarted} ä¸ªå¯†é’¥å®Œæˆæµ‹è¯•`;
                document.getElementById('batchProgressText').textContent = progress;
            }
        }
        
        function categorizeResults(results) {
            const categories = {
                perfect: [],
                excellent: [],
                qualified: [],
                unstable: { group1: [], group2: [], group3: [] },
                invalid: [],
                error: [],
                manualStop: []
            };
            
            const processedKeys = new Set();
            
            results.forEach(result => {
                if (processedKeys.has(result.key)) {
                    return;
                }
                processedKeys.add(result.key);
                
                // è°ƒè¯•ä¿¡æ¯
                console.log(`åˆ†ç±»å¯†é’¥: ${result.key.substring(0, 20)}...`, {
                    successRate: result.successRate,
                    failAt: result.failAt,
                    totalTests: result.totalTests,
                    successCount: result.successCount,
                    errorType: result.errorType
                });
                
                // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯æ— æ•ˆå¯†é’¥
                if (result.errorType === 'invalid_key' || result.errorType === 'bad_request') {
                    categories.invalid.push(result);
                }
                // æ‰‹åŠ¨åœæ­¢
                else if (result.stoppedByUser) {
                    categories.manualStop.push(result);
                }
                // å…¶ä»–é”™è¯¯ï¼ˆç½‘ç»œã€è¶…æ—¶ç­‰ï¼‰
                else if (result.errorType && result.errorType !== '429') {
                    categories.error.push(result);
                }
                // æ ¹æ®æˆåŠŸç‡å’Œ429å‡ºç°æ—¶æœºåˆ†ç±»
                else if (result.failAt) {
                    // æœ‰429é”™è¯¯ï¼Œæ ¹æ®æˆåŠŸç‡å’Œå‡ºç°æ—¶æœºç»¼åˆåˆ¤æ–­
                    const successRate = result.successRate;
                    
                    if (successRate >= 95 && result.failAt >= 95) {
                        categories.perfect.push(result);
                    } else if (successRate >= 80 && result.failAt >= 70) {
                        categories.excellent.push(result);
                    } else if (successRate >= 60 && result.failAt >= 50) {
                        categories.qualified.push(result);
                    } else if (result.failAt >= 30) {
                        categories.unstable.group1.push(result);
                    } else if (result.failAt >= 15) {
                        categories.unstable.group2.push(result);
                    } else {
                        categories.unstable.group3.push(result);
                    }
                }
                // å®Œæˆ100æ¬¡æµ‹è¯•æ²¡æœ‰429
                else if (result.totalTests === 100) {
                    // æ ¹æ®æˆåŠŸç‡åˆ¤æ–­
                    const successRate = result.successRate;
                    
                    if (successRate >= 95) {
                        categories.perfect.push(result);
                    } else if (successRate >= 80) {
                        categories.excellent.push(result);
                    } else if (successRate >= 60) {
                        categories.qualified.push(result);
                    } else {
                        // æˆåŠŸç‡å¤ªä½ï¼Œå½’ä¸ºä¸ç¨³å®š
                        categories.unstable.group3.push(result);
                    }
                }
                // å…¶ä»–æƒ…å†µ
                else {
                    categories.error.push(result);
                }
            });
            
            // è¾“å‡ºè°ƒè¯•ä¿¡æ¯
            console.log('åˆ†ç±»ç»“æœ:', {
                perfect: categories.perfect.length,
                excellent: categories.excellent.length,
                qualified: categories.qualified.length,
                unstable: categories.unstable.group1.length + categories.unstable.group2.length + categories.unstable.group3.length,
                invalid: categories.invalid.length,
                error: categories.error.length,
                manualStop: categories.manualStop.length
            });
            
            return categories;
        }
        
        function displayResults(categories) {
            if (state.finalUpdatePending) {
                doDisplayResults(categories);
                state.finalUpdatePending = false;
                return;
            }
            
            if (state.updateTimer) {
                clearTimeout(state.updateTimer);
            }
            
            state.updateTimer = setTimeout(() => {
                doDisplayResults(categories);
            }, 100);
        }
        
        function doDisplayResults(categories) {
            if (state.renderRequestId) {
                cancelAnimationFrame(state.renderRequestId);
                state.renderRequestId = null;
            }
            
            state.renderRequestId = requestAnimationFrame(() => {
                const fragments = {
                    perfect: document.createDocumentFragment(),
                    excellent: document.createDocumentFragment(),
                    qualified: document.createDocumentFragment(),
                    unstable1: document.createDocumentFragment(),
                    unstable2: document.createDocumentFragment(),
                    unstable3: document.createDocumentFragment(),
                    invalid: document.createDocumentFragment(),
                    error: document.createDocumentFragment(),
                    manualStop: document.createDocumentFragment()
                };
                
                const createKeyElements = (keys, fragment, className) => {
                    keys.forEach(keyData => {
                        const keyItem = document.createElement('div');
                        keyItem.className = `key-item ${className}`;
                        keyItem.setAttribute('data-full-key', keyData.key);
                        
                        let statusText = '';
                        let statusColor = '#17a2b8';
                        
                        if (keyData.failAt) {
                            statusText = `ç¬¬${keyData.failAt}æ¬¡å‡ºç°429`;
                            statusColor = '#dc3545';
                        } else if (keyData.totalTests === 100) {
                            statusText = `å®Œæˆ100æ¬¡`;
                            statusColor = '#28a745';
                        } else if (keyData.errorType === 'invalid_key') {
                            statusText = `æ— æ•ˆå¯†é’¥`;
                            statusColor = '#dc3545';
                        } else if (keyData.errorType === 'bad_request') {
                            statusText = `è¯·æ±‚é”™è¯¯`;
                            statusColor = '#dc3545';
                        } else if (keyData.errorType === 'network') {
                            statusText = `ç½‘ç»œé”™è¯¯`;
                            statusColor = '#dc3545';
                        } else if (keyData.errorType === 'max_retries_exceeded') {
                            statusText = `é‡è¯•å¤±è´¥`;
                            statusColor = '#dc3545';
                        } else if (keyData.errorType) {
                            statusText = `é”™è¯¯: ${keyData.errorType}`;
                            statusColor = '#dc3545';
                        } else if (keyData.stoppedByUser) {
                            statusText = `æ‰‹åŠ¨åœæ­¢`;
                            statusColor = '#fd7e14';
                        } else {
                            statusText = `æµ‹è¯•${keyData.totalTests}æ¬¡`;
                            statusColor = '#17a2b8';
                        }
                        
                        const successRate = keyData.successRate ? keyData.successRate.toFixed(1) : '0.0';
                        const rateColor = keyData.successRate >= 80 ? '#28a745' : 
                                        keyData.successRate >= 60 ? '#ffc107' : '#dc3545';
                        
                        const displayKey = keyData.key.substring(0, 20) + (keyData.key.length > 20 ? '...' : '');
                        
                        keyItem.innerHTML = `
                            <span class="key-text">${displayKey}</span>
                            <div class="key-stats">
                                <span>æˆåŠŸ: ${keyData.successCount}/${keyData.totalTests}</span>
                                <span style="color: ${rateColor}; font-weight: bold;">${successRate}%</span>
                                <span style="color: ${statusColor};">${statusText}</span>
                            </div>
                        `;
                        
                        fragment.appendChild(keyItem);
                    });
                };
                
                createKeyElements(categories.perfect, fragments.perfect, 'perfect');
                createKeyElements(categories.excellent, fragments.excellent, 'excellent');
                createKeyElements(categories.qualified, fragments.qualified, 'qualified');
                createKeyElements(categories.unstable.group1, fragments.unstable1, 'unstable');
                createKeyElements(categories.unstable.group2, fragments.unstable2, 'unstable');
                createKeyElements(categories.unstable.group3, fragments.unstable3, 'unstable');
                createKeyElements(categories.invalid, fragments.invalid, 'invalid');
                createKeyElements(categories.error, fragments.error, 'error');
                createKeyElements(categories.manualStop, fragments.manualStop, 'manual-stop');
                
                const updateContainer = (id, fragment) => {
                    const container = document.getElementById(id);
                    if (container) {
                        container.innerHTML = '';
                        container.appendChild(fragment);
                    }
                };
                
                updateContainer('perfectKeys', fragments.perfect);
                updateContainer('excellentKeys', fragments.excellent);
                updateContainer('qualifiedKeys', fragments.qualified);
                updateContainer('unstable1', fragments.unstable1);
                updateContainer('unstable2', fragments.unstable2);
                updateContainer('unstable3', fragments.unstable3);
                updateContainer('invalidKeys', fragments.invalid);
                updateContainer('errorKeys', fragments.error);
                updateContainer('manualStopKeys', fragments.manualStop);
                
                document.getElementById('perfectCount').textContent = `(${categories.perfect.length})`;
                document.getElementById('excellentCount').textContent = `(${categories.excellent.length})`;
                document.getElementById('qualifiedCount').textContent = `(${categories.qualified.length})`;
                const unstableTotal = categories.unstable.group1.length + 
                                    categories.unstable.group2.length + 
                                    categories.unstable.group3.length;
                document.getElementById('unstableCount').textContent = `(${unstableTotal})`;
                document.getElementById('invalidCount').textContent = `(${categories.invalid.length})`;
                document.getElementById('errorCount').textContent = `(${categories.error.length})`;
                document.getElementById('manualStopCount').textContent = `(${categories.manualStop.length})`;
                
                state.renderRequestId = null;
                state.updateTimer = null;
            });
        }
        
        function updateStats() {
            document.getElementById('totalKeys').textContent = state.totalKeysCount;
            document.getElementById('testedKeys').textContent = state.testedKeysCount;
            document.getElementById('currentBatch').textContent = state.currentBatchNum;
            document.getElementById('totalRequests').textContent = state.totalRequestsCount;
        }
        
        function updateProgress() {
            const progress = state.totalKeysCount > 0 ? 
                (state.testedKeysCount / state.totalKeysCount * 100).toFixed(1) : 0;
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = `${progress}%`;
            progressFill.textContent = `${progress}%`;
            
            if (state.startTime && state.isRunning) {
                const elapsed = (Date.now() - state.startTime) / 1000;
                if (state.testedKeysCount > 0) {
                    const avgTimePerKey = elapsed / state.testedKeysCount;
                    const remainingKeys = state.totalKeysCount - state.testedKeysCount;
                    const remainingSeconds = Math.max(0, Math.floor(avgTimePerKey * remainingKeys));
                    
                    const hours = Math.floor(remainingSeconds / 3600);
                    const minutes = Math.floor((remainingSeconds % 3600) / 60);
                    const seconds = Math.floor(remainingSeconds % 60);
                    
                    let timeText = '';
                    if (hours > 0) timeText += `${hours}å°æ—¶`;
                    if (minutes > 0) timeText += `${minutes}åˆ†`;
                    timeText += `${seconds}ç§’`;
                    
                    document.getElementById('currentProgress').textContent = `å‰©ä½™æ—¶é—´: ${timeText}`;
                }
            }
        }
        
        async function startTesting() {
            const keysText = document.getElementById('apiKeys').value.trim();
            if (!keysText) {
                alert('è¯·è¾“å…¥APIå¯†é’¥ï¼');
                return;
            }
            
            const allKeys = keysText.split('\n')
                .map(key => key.trim())
                .filter(key => key && key.startsWith('AIzaSy'));
            
            const uniqueKeys = [...new Set(allKeys)];
            
            if (uniqueKeys.length === 0) {
                alert('æ²¡æœ‰æœ‰æ•ˆçš„APIå¯†é’¥ï¼Gemini APIå¯†é’¥åº”ä»¥ AIzaSy å¼€å¤´ã€‚');
                return;
            }
            
            const batchSize = parseInt(document.getElementById('batchSize').value) || 230;
            const interval = parseInt(document.getElementById('interval').value) || 20;
            const launchDelay = parseInt(document.getElementById('launchDelay').value) || 1000;
            state.verboseLogging = document.getElementById('verboseLog').checked;
            
            const totalBatches = Math.ceil(uniqueKeys.length / batchSize);
            
            const launchTimePerBatch = (Math.min(batchSize, uniqueKeys.length) - 1) * launchDelay / 1000;
            const maxTestTimePerKey = 50 * interval;
            const totalEstimatedTime = totalBatches * (launchTimePerBatch + maxTestTimePerKey);
            const estimatedMinutes = Math.ceil(totalEstimatedTime / 60);
            const estimatedHours = Math.floor(estimatedMinutes / 60);
            const remainingMinutes = estimatedMinutes % 60;
            
            const timeText = estimatedHours > 0 ? 
                `${estimatedHours}å°æ—¶${remainingMinutes}åˆ†é’Ÿ` : 
                `${estimatedMinutes}åˆ†é’Ÿ`;
            
            document.getElementById('estimatedTime').textContent = timeText;
            document.getElementById('timeEstimate').style.display = 'block';
            
            if (!confirm(`å³å°†æµ‹è¯• ${uniqueKeys.length} ä¸ªå¯†é’¥
æ‰¹æ¬¡å¤§å°ï¼š${batchSize}
æ€»æ‰¹æ¬¡æ•°ï¼š${totalBatches}
è¯·æ±‚é—´éš”ï¼š${interval} ç§’
å¯åŠ¨å»¶æ—¶ï¼š${launchDelay} æ¯«ç§’
è¯¦ç»†æ—¥å¿—ï¼š${state.verboseLogging ? 'å¼€å¯' : 'å…³é—­'}
é¢„è®¡æ—¶é—´ï¼šçº¦ ${timeText}

âš ï¸ æ³¨æ„ï¼šåªæœ‰æˆåŠŸç‡â‰¥95%ä¸”429å‡ºç°åœ¨95æ¬¡åçš„å¯†é’¥æ‰ç®—å®Œç¾ï¼

ç¡®å®šå¼€å§‹å—ï¼Ÿ`)) {
                document.getElementById('timeEstimate').style.display = 'none';
                return;
            }
            
            // é‡ç½®çŠ¶æ€
            state.isRunning = true;
            state.totalKeysCount = uniqueKeys.length;
            state.testedKeysCount = 0;
            state.currentBatchNum = 0;
            state.totalRequestsCount = 0;
            state.testResults.clear();
            state.keyAbortControllers.clear();
            state.activePromises.clear();
            state.startTime = Date.now();
            state.finalUpdatePending = false;
            state.finalCategories = null;
            
            if (supportsAbortController) {
                state.currentAbortController = new AbortController();
            }
            
            if (state.updateTimer) {
                clearTimeout(state.updateTimer);
                state.updateTimer = null;
            }
            
            if (state.renderRequestId) {
                cancelAnimationFrame(state.renderRequestId);
                state.renderRequestId = null;
            }
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('testingIndicator').classList.add('active');
            document.getElementById('batchInfo').style.display = 'block';
            
            updateStats();
            updateProgress();
            
            addLog(`========== å¼€å§‹æµ‹è¯• ==========`);
            addLog(`æ€»å¯†é’¥æ•°ï¼š${uniqueKeys.length}`);
            addLog(`æ‰¹æ¬¡å¤§å°ï¼š${batchSize}`);
            addLog(`æ€»æ‰¹æ¬¡æ•°ï¼š${totalBatches}`);
            addLog(`è¯·æ±‚é—´éš”ï¼š${interval}ç§’`);
            addLog(`å¯åŠ¨å»¶æ—¶ï¼š${launchDelay}ms`);
            addLog(`è¯¦ç»†æ—¥å¿—ï¼š${state.verboseLogging ? 'å¼€å¯' : 'å…³é—­'}`);
            
            try {
                for (let i = 0; i < uniqueKeys.length; i += batchSize) {
                    if (!state.isRunning) break;
                    
                    state.currentBatchNum++;
                    const batch = uniqueKeys.slice(i, Math.min(i + batchSize, uniqueKeys.length));
                    const batchDetails = `ç¬¬ ${state.currentBatchNum}/${totalBatches} æ‰¹ï¼ŒåŒ…å« ${batch.length} ä¸ªå¯†é’¥ (${i+1}-${Math.min(i+batchSize, uniqueKeys.length)}/${uniqueKeys.length})`;
                    document.getElementById('batchDetails').textContent = batchDetails;
                    
                    await processBatch(batch, state.currentBatchNum, totalBatches);
                    
                    if (state.isRunning && state.currentBatchNum < totalBatches) {
                        addLog(`å‡†å¤‡å¼€å§‹ç¬¬ ${state.currentBatchNum + 1} æ‰¹...`);
                    }
                }
            } catch (error) {
                console.error('æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
                addLog('æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ' + error.message, 'error');
            } finally {
                state.finalUpdatePending = true;
                const allResults = Array.from(state.testResults.values());
                const categories = categorizeResults(allResults);
                state.finalCategories = categories;
                displayResults(categories);
                
                state.isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('testingIndicator').classList.remove('active');
                document.getElementById('currentTesting').style.display = 'none';
                document.getElementById('timeEstimate').style.display = 'none';
                document.getElementById('batchLaunchInfo').style.display = 'none';
                document.getElementById('batchProgress').style.display = 'none';
                
                if (state.testedKeysCount === uniqueKeys.length) {
                    addLog('========== æ‰€æœ‰æµ‹è¯•å®Œæˆ ==========');
                    const finalCategories = state.finalCategories || categories;
                    const summary = `
æµ‹è¯•å®Œæˆï¼æ€»è®¡ï¼š${uniqueKeys.length} ä¸ªå¯†é’¥
âœ¨ å®Œç¾(æˆåŠŸç‡â‰¥95% ä¸” 429â‰¥95æ¬¡)ï¼š${finalCategories.perfect.length}
ğŸŒŸ ä¼˜ç§€(æˆåŠŸç‡â‰¥80% ä¸” 429â‰¥70æ¬¡)ï¼š${finalCategories.excellent.length}
âœ… åˆæ ¼(æˆåŠŸç‡â‰¥60% ä¸” 429â‰¥50æ¬¡)ï¼š${finalCategories.qualified.length}
âš ï¸ ä¸ç¨³å®š(æˆåŠŸç‡<60% æˆ– 429è¿‡æ—©)ï¼š${finalCategories.unstable.group1.length + finalCategories.unstable.group2.length + finalCategories.unstable.group3.length}
âŒ æ— æ•ˆå¯†é’¥ï¼š${finalCategories.invalid.length}
âš ï¸ å…¶ä»–é”™è¯¯ï¼š${finalCategories.error.length}
ğŸ›‘ æ‰‹åŠ¨åœæ­¢ï¼š${finalCategories.manualStop.length}
æ€»è¯·æ±‚æ•°ï¼š${state.totalRequestsCount}
                    `;
                    alert(summary.trim());
                } else {
                    addLog('========== æµ‹è¯•å·²åœæ­¢ ==========', 'warning');
                }
                
                state.currentAbortController = null;
                state.startTime = null;
            }
        }
        
        async function stopTesting() {
            state.isRunning = false;
            
            if (supportsAbortController) {
                if (state.currentAbortController) {
                    try {
                        state.currentAbortController.abort();
                    } catch (e) {
                        console.error('Error aborting main controller:', e);
                    }
                    state.currentAbortController = null;
                }
                
                for (const [key, controller] of state.keyAbortControllers) {
                    try {
                        controller.abort();
                    } catch (e) {
                        console.error('Error aborting key controller:', e);
                    }
                }
                state.keyAbortControllers.clear();
            }
            
            if (state.activePromises.size > 0) {
                addLog(`ç­‰å¾… ${state.activePromises.size} ä¸ªä»»åŠ¡å®Œæˆ...`, 'warning');
                try {
                    await Promise.allSettled(Array.from(state.activePromises));
                } catch (e) {
                    console.error('Error waiting for active promises:', e);
                }
                state.activePromises.clear();
            }
            
            state.finalUpdatePending = true;
            const allResults = Array.from(state.testResults.values());
            const categories = categorizeResults(allResults);
            state.finalCategories = categories;
            displayResults(categories);
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('testingIndicator').classList.remove('active');
            document.getElementById('currentTesting').style.display = 'none';
            document.getElementById('timeEstimate').style.display = 'none';
            document.getElementById('batchLaunchInfo').style.display = 'none';
            document.getElementById('batchProgress').style.display = 'none';
            state.startTime = null;
            
            addLog('æµ‹è¯•å·²åœæ­¢', 'warning');
        }
        
        function clearResults() {
            if (state.isRunning) {
                alert('è¯·å…ˆåœæ­¢æµ‹è¯•ï¼');
                return;
            }
            
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æµ‹è¯•ç»“æœå—ï¼Ÿ')) {
                return;
            }
            
            state.testResults.clear();
            state.keyAbortControllers.clear();
            state.activePromises.clear();
            state.finalCategories = null;
            
            if (state.updateTimer) {
                clearTimeout(state.updateTimer);
                state.updateTimer = null;
            }
            
            if (state.renderRequestId) {
                cancelAnimationFrame(state.renderRequestId);
                state.renderRequestId = null;
            }
            
            ['perfectKeys', 'excellentKeys', 'qualifiedKeys', 
             'unstable1', 'unstable2', 'unstable3', 
             'invalidKeys', 'errorKeys', 'manualStopKeys', 'logContent'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = '';
            });
            
            ['perfectCount', 'excellentCount', 'qualifiedCount', 
             'unstableCount', 'invalidCount', 'errorCount', 'manualStopCount'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = '(0)';
            });
            
            state.totalKeysCount = 0;
            state.testedKeysCount = 0;
            state.currentBatchNum = 0;
            state.totalRequestsCount = 0;
            updateStats();
            
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = '0%';
            progressFill.textContent = '0%';
            
            document.getElementById('batchInfo').style.display = 'none';
            document.getElementById('timeEstimate').style.display = 'none';
            
            addLog('å·²æ¸…ç©ºæ‰€æœ‰ç»“æœ');
        }
        
        function copyGroup(groupName) {
            let keys = [];
            
            switch(groupName) {
                case 'perfect':
                    keys = extractKeysFromElement('perfectKeys');
                    break;
                case 'excellent':
                    keys = extractKeysFromElement('excellentKeys');
                    break;
                case 'qualified':
                    keys = extractKeysFromElement('qualifiedKeys');
                    break;
                case 'unstable':
                    keys = [
                        ...extractKeysFromElement('unstable1'),
                        ...extractKeysFromElement('unstable2'),
                        ...extractKeysFromElement('unstable3')
                    ];
                    break;
                case 'invalid':
                    keys = extractKeysFromElement('invalidKeys');
                    break;
                case 'manualStop':
                    keys = extractKeysFromElement('manualStopKeys');
                    break;
                case 'error':
                    keys = extractKeysFromElement('errorKeys');
                    break;
            }
            
            keys = keys.filter(key => key && typeof key === 'string' && key.trim().length > 0);
            
            if (keys.length === 0) {
                alert('è¯¥åˆ†ç»„æ²¡æœ‰å¯†é’¥');
                return;
            }
            
            const keysText = keys.join('\n');
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(keysText).then(() => {
                    alert(`å·²å¤åˆ¶ ${keys.length} ä¸ªå¯†é’¥åˆ°å‰ªè´´æ¿`);
                }).catch(() => {
                    fallbackCopyTextToClipboard(keysText, keys.length);
                });
            } else {
                fallbackCopyTextToClipboard(keysText, keys.length);
            }
        }
        
        function fallbackCopyTextToClipboard(text, count) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.top = '0';
            textarea.style.left = '0';
            textarea.style.width = '2em';
            textarea.style.height = '2em';
            textarea.style.padding = '0';
            textarea.style.border = 'none';
            textarea.style.outline = 'none';
            textarea.style.boxShadow = 'none';
            textarea.style.background = 'transparent';
            
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    alert(`å·²å¤åˆ¶ ${count} ä¸ªå¯†é’¥åˆ°å‰ªè´´æ¿`);
                } else {
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
                }
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
            }
            
            document.body.removeChild(textarea);
        }
        
        function extractKeysFromElement(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return [];
            const keyElements = element.querySelectorAll('.key-item[data-full-key]');
            return Array.from(keyElements)
                .map(el => el.getAttribute('data-full-key'))
                .filter(key => key && typeof key === 'string' && key.trim().length > 0);
        }
        
        function exportResults() {
            const allResults = Array.from(state.testResults.values());
            if (allResults.length === 0) {
                alert('æ²¡æœ‰æµ‹è¯•ç»“æœå¯å¯¼å‡º');
                return;
            }
            
            const categories = categorizeResults(allResults);
            const timestamp = new Date().toISOString();
            
            const report = {
                timestamp,
                summary: {
                    totalKeys: state.totalKeysCount,
                    testedKeys: state.testedKeysCount,
                    totalRequests: state.totalRequestsCount,
                    perfect: categories.perfect.length,
                    excellent: categories.excellent.length,
                    qualified: categories.qualified.length,
                    unstable: categories.unstable.group1.length + categories.unstable.group2.length + categories.unstable.group3.length,
                    invalid: categories.invalid.length,
                    manualStop: categories.manualStop.length,
                    error: categories.error.length
                },
                details: allResults.map(r => ({
                    key: r.key,
                    successCount: r.successCount,
                    totalTests: r.totalTests,
                    successRate: r.successRate,
                    failAt: r.failAt,
                    errorType: r.errorType,
                    networkErrors: r.networkErrors,
                    timeoutErrors: r.timeoutErrors,
                    serverErrors: r.serverErrors
                })),
                categories: {
                    perfect: categories.perfect.map(r => r.key),
                    excellent: categories.excellent.map(r => r.key),
                    qualified: categories.qualified.map(r => r.key),
                    unstable: {
                        group1: categories.unstable.group1.map(r => r.key),
                        group2: categories.unstable.group2.map(r => r.key),
                        group3: categories.unstable.group3.map(r => r.key)
                    },
                    invalid: categories.invalid.map(r => r.key),
                    error: categories.error.map(r => r.key),
                    manualStop: categories.manualStop.map(r => r.key)
                }
            };
            
            const dataStr = JSON.stringify(report, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', `gemini-test-report-${new Date().getTime()}.json`);
            linkElement.click();
            
            addLog('æµ‹è¯•æŠ¥å‘Šå·²å¯¼å‡º');
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            updateStats();
            
            if (!supportsAbortController) {
                addLog('è­¦å‘Šï¼šæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ AbortControllerï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½å—é™', 'warning');
            }
            
            // é»˜è®¤å¼€å¯è¯¦ç»†æ—¥å¿—
            document.getElementById('verboseLog').checked = true;
            
            addLog('ç³»ç»Ÿå·²å‡†å¤‡å°±ç»ª - å¢å¼ºç‰ˆ', 'success');
        });
        
        window.addEventListener('beforeunload', (e) => {
            if (state.isRunning) {
                e.preventDefault();
                e.returnValue = 'æµ‹è¯•æ­£åœ¨è¿›è¡Œä¸­ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ';
                return e.returnValue;
            }
        });
    </script>
</body>
</html>
````

**æ ¸å¿ƒä¿®å¤å†…å®¹ï¼š**

1. **å®Œå…¨é‡å†™åˆ†ç±»é€»è¾‘** - ç°åœ¨åŒæ—¶è€ƒè™‘æˆåŠŸç‡å’Œ429å‡ºç°æ—¶æœº
2. **å¢åŠ è¯¦ç»†æ—¥å¿—é€‰é¡¹** - å¯ä»¥çœ‹åˆ°æ¯æ¬¡è¯·æ±‚çš„å…·ä½“ç»“æœ
3. **æ·»åŠ å®æ—¶æµ‹è¯•çŠ¶æ€æ˜¾ç¤º** - æ˜¾ç¤ºå½“å‰æµ‹è¯•çš„å¯†é’¥ã€è¿›åº¦ã€æˆåŠŸç‡
4. **ä¿®æ­£æˆåŠŸç‡è®¡ç®—** - åœ¨æ¯ä¸ªåœ°æ–¹éƒ½æ­£ç¡®è®¡ç®—å’Œæ˜¾ç¤ºæˆåŠŸç‡
5. **å¢åŠ "æ— æ•ˆå¯†é’¥"åˆ†ç±»** - ä¸“é—¨å¤„ç†è®¤è¯å¤±è´¥çš„å¯†é’¥
6. **æ”¹è¿›UIæ˜¾ç¤º** - ç”¨ä¸åŒé¢œè‰²æ˜¾ç¤ºæˆåŠŸç‡ï¼Œæ›´ç›´è§‚
7. **å¢åŠ è°ƒè¯•ä¿¡æ¯** - åœ¨æ§åˆ¶å°è¾“å‡ºåˆ†ç±»å†³ç­–è¿‡ç¨‹

ç°åœ¨ï¼Œåªæœ‰æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„å¯†é’¥æ‰ä¼šè¢«å½’ä¸º"å®Œç¾"ï¼š
- æˆåŠŸç‡ â‰¥ 95%
- 429é”™è¯¯å‡ºç°åœ¨ç¬¬95æ¬¡æˆ–ä¹‹å
- æˆ–è€…å®Œæˆ100æ¬¡æµ‹è¯•ä¸”æˆåŠŸç‡ â‰¥ 95%